# 신입 안드로이드 개발자로 취업하기 - 면접

> 부제 : 면접 준비 한방에 가즈아~~~
>
> 작성자 : 박태임

> Present Time : 2018-10-23-TUE

</br>

## 1. 내가 생각한 기술면접의 두 가지 유형

- 자바 기초, 알고리즘, 자료구조 등에 관련된 질문
- 내 이력서, 포트폴리오에서 사용한 기술들에 관련된 질문

스타트업은 후자의 비중이 더 큰 것 같고, 대기업이나 신입들의 기초를 중요시하게 생각하는 기업은 면접에서 전자의 비중이 더 큰 것 같다. 



</br></br>



## 2. 자바 기초 면접질문

#### 1. 객체와 클래스 차이점

**클래스는 객체를 생성하기 위한 설계도 또는 틀**이라고 볼 수 있고, **객체는 설계도 또는 틀로 찍어낸 실체**라고 볼 수 있다. 객체를 클래스의 인스턴스라고도 부르며 객체와 인스턴스 두 용어를 구별없이 사용한다.

**클래스는 객체들이 어떤 특성을 갖는다고 정의만**하고 값은 가질 수 없으나 **객체는 실존하며 각각 자신만의 고유한 속성 값**을 갖는다. 



#### 2. 자바 기본형과 wrapper 클래스 차이점

8개의 기본 데이터를 객체 형식으로 다루기위해 JDK에 의해 지원되는 8개의 클래스(Byte, Short, Integer, Long, Character, Double, Float, Boolean)를 통칭하여 Wrapper 클래스라고 말한다.

int, double 등 자바 기본 데이터 타입은 클래스가 아니다. 따라서 기본 데이터 값도 객체가 아니다. 



#### 3. 자바 컬렉션 종류와 차이점

Set : 중복X, 순서X

List : 중복허용, 순서 유지

컬렉션은 가변 크기로서 객체의 개수를 염려할 필요가 없다. 컬렉션 내의 한 객체가 삭제되면 컬렉션이 자동으로 자리를 옮겨준다.

Vector<E> : List<E> 인터페이스를 구현한 클래스. 가변 개수의 배열이 필요할 때 적합. 벡터에 삽입되는 요소의 수가 많아지면 자동으로 크기가 조절됨. 요소는 벡터의 맨 마지막이나 중간에 삽입될 수 있다. 이 경우 벡터는 삽입되는 요소의 뒤에 있는 모든 요소들을 한 자리씩 뒤로 이동시킨다. 

무조건 동기화 -> 성능이 많이 떨어짐, 쓸일이 별로 없어짐 왜냐면 동기화 처리가 필요할 때  Collection, synchronizedCollection, synchronizedList,Map 등을 이용하는게 성능적으로 더 좋음.

ArrayList<E> : Vector클래스와 거의 동일. 크게 다른 점은 ArrayList는 스레드 간에 동기화를 지원하지 않기 때문에, 다수의 스레드가 동시에 요소를 삽입하거나 삭제할 때 충돌이 발생할 수 있다. ArrayList를 이용하려면 멀티스레드의 동기화를 직접 구현해야 한다.

HashMap<K,V> : 키, 값의 쌍으로 구성되는 요소를 다룸. 

LinkedList<E> : List 인터페이스를 구현한 클래스. 요소들을 양방향으로 연결하여 관리한다는 점을 제외하고 Vector, ArrayList와 매우 유사. LinkedList는 맨 앞과 맨 뒤를 가리키는 head,tail, 레퍼런스를 가지고 있어, 맨 앞이나 맨 뒤, 중간에 요소의 삽입이 가능하며 인덱스를 이용하여 요소에 접근할 수도 있음.



#### 4. equals VS.  == 연산자  차이점

**equals** : 문자열 자체를 비교

**== 연산자** : 객체의 주소값을 비교



##### 4-1. 위 코드의 결과를 예상

``` java
String s1 = "abc";
String s2 = new String("abc");
s1 == s2;
```

false.

이유는? 

String s1 = “123”은 **String Pool에서 관리** 된다. 따라서 두 개의 문자열 변수를지정했지만 Jvm Heap 메모리의 String Pool에는“Hello”라는 문자열 하나만 존재한다. 

**new 키워드**를 사용한 두번째 문장은, **Heap에 객체를 생성**하게 된다.

같은 객체를 참조하는것이 아니기 때문에 결과가 false가 된다. (==연산자는객체의 주소값을 비교)



##### 4-2. 위 연산을 true로 만들려면 어떻게 해야 할까?

1. **s1.equals(s2)** 는 문자열 자체를 비교한 결과를 돌려받기 때문에 -> true

2. **s2.intern()** 메서드를 이용하면 String pool에 등록할 수 있다. -> true

   ​

#### 5. 추상화란?

**어떤 객체를 표현함에 있어** 모든 것을 다 표현하는 것이 아니라 **일정 부분 특징만을 표현**. 추상화를 하게 되면 목적을 위해 필요한 부분만을 찾을 수 있다. **(공통된 개념과 관계에 집중할 수 있게 됨)**



#### 6. 추상클래스란?

1. 추상 메소드(선언은되어있으나 코드 구현X, 껍데기만 있는)를 포함하는 클래스(abstract로 선언)   
2. 추상메소드가 하나도 없지만 abstract로 선언한 클래스



##### 6-1. 추상클래스의 용도 

추상클래스를 상속받은 서브 클래스는 개발자에 따라 다양하게 구현 (하지만 모든 개발자들이 서브 클래스에서 추상 클래스에 선언된 추상 메소드를 모두 구현해야 한다) 

추상클래스를 책의 목차에 비유하면, 서브 클래스는 콕차에 따라 작성된실제 책과 같다. 

추상 클래스를 이용하면 응용프로그램의 설계와 구현을 분리할 수 있다. 

추상 클래스로 기본 방향을 잡아놓고 서브 클래스에서 구현하면 구현 작업에 쉬워진다. 또한, 추상 클래스는 계층적 상속 관계를 가지는 클래스들의 구조를만들 때 적합하다.



#### 7. 인터페이스란?

1. 자바의 인터페이스는 추상 클래스와 유사. 

2. 인터페이스는 규격과 같은 것.(따라서 인터페이스에 수정을 가할 때는 기존 인터페이스를 상속받아 새로운 인터페이스를 만듬. 자바에서 클래스의 다중상속X, 인터페이스 다중상속O)

3. 멤버는 추상메소드(publicabstract), 상수(public static final) 만으로 구성 

4. 모든 메소드는 public이며 생략 가능 

5. 객체 생성X   

6. 다른 인터페이스 상속O (인터페이스는다른 인터페이스를 상속O) 

7. 인터페이스 구현 : 

   인터페이스의추상 메소드를 클래스에서 구현하는 것. (implements 키워드)

   이때 클래스는반드시 인터페이스의 모든 추상메소드를 구현해야 함.

8. 인터페이스왜 사용?

   사용될클래스가 어떠한 메소드,멤버들을 갖고 있는가에 대한 명세서와 같은 역할.

   ​

#### 8. 추상클래스 VS. 인터페이스 차이점

| 추상클래스                                 | 인터페이스           |
| ------------------------------------- | --------------- |
| 일반 메소드 포함 가능                          | 모든 메소드가 추상 메소드  |
| 상수 필드만 포함 가능                          | 상수, 변수 필드 포함 가능 |
| 모든 서브 클래스에 공통된 메소드가 있는 경우에는 추상클래스가 적합 | 다중 상속 지원        |

 



#### 9. String Mutable 이란?

**Immutable(가변) 객체** : 객체 내의 특정요소를 변경 할 수 있는 객체 (Ex. List,ArrayList, HashMap)

**Mutable(불변) 객체** : 

객체 내의 특정 요소의 값을 변경 할 수 없는 객체 (Ex. String,Integer, Double, Long)

Set 메소드 X,  heap 영역에서 변경불가라는 뜻(String a=”a”; a=”b” 와 같은 재할당은 가능)



##### 9-1. StringBuffer vs. String

StringBuffer는 Mutable



#### 10. String Pool이 위치하는 영역은?

Heap 영역.

Perm 영역에서 Java7에서Heap으로 바뀜 -> 이점 : String pool의 모든 문자열도 GC의 대상이 될 수 있음.



</br></br>



## 3. 안드로이드 면접질문

#### 1. Thread간 통신방법에 대해 설명

Handler를 이용

두 개 이상의 스레드를 사용할 때의 동기화 이슈를 차단하기 위해 Looper와 Handler를 사용



#### 2. Handler 설명

Handler는 Looper로부터 받은 Message를 실행, 처리하거나 다른 스레드로부터 메시지를 받아서 Message Queue에 넣는 역할을 하는 스레드 간의 통신 장치이다.

일반적으로 UI갱신을 위해 사용. (뷰나 뷰그룹에서 제공하는 메소드는 단일 스레드 모델(Thread-Unsafe))

핸들러는 두 종류의 객체를 메시지 큐(Message Queue)를 통해 특정 스레드로 전달한다.

문자와 필드로 구성된 메시지 객체 & Runnable 객체

![thread-looper-handler](/Users/parktaeim/Documents/GitHub/Android-Study/study/week16/안드로이드 개발자로 취업하기 - 면접/images/thread-looper-handler.png)



#### 3. Looper에 대해 설명

Looper는 무한히 루프를 돌며 자신히 속한 스레드의 Message Queue에서 Message나 Runnable 객체를 차례로 꺼내 Handler가 처리하도록 전달한다.

메인 스레드에는 Looper가 기본적으로 생성되어 있지만, 새로 생성한 스레드는 Looper를 가지고 있지 않기 때문에 메시지를 받을 수 없다. 사용할 수 있는 메시지 큐가 없기 때문이다. 서브 스레드에서 메시지를 전달받기 위해서는 Looper를 생성해주어야 함 (but, Looper 자동 보유클래스-> HandlerThread)



#### 4. 백그라운드에서 UI 업데이트 하는 방법

Handler.post, Looper Handler, mainThread 안에 Handler 만들어 놓고 다른쓰레드에서 메시지 넣어주기, runOnUIThread, AsyncTask



#### 5. Context에 대해 설명

현재 사용되고 있는 어플리케이션(또는 액티비티)에 대한 포괄적인 정보를 지니고 있는 객체



#### 6. Activity의 생명주기에 대해 얘기하고 각 항목에 대해 설명

![activity_lifecycle](/Users/parktaeim/Documents/GitHub/Android-Study/study/week16/안드로이드 개발자로 취업하기 - 면접/images/activity_lifecycle.png)

##### 6-1. 앱을 사용하는 도중에 카카오톡 메세**지가 온다면 사용하던 앱의 TopActivity의 생명주기는 어떤 상태가 되나요?**

onPause 상태가 됩니다.

##### 6-2. 데이터 불러오는 작업은 어디서 해야할까?

\- Activity가 중지 상태에서 다시 화면에 표시되기 직전에 호출됩니다. onRestart->onStart->onResume-> ActivityRunning..

##### 6-3. 다른 액티비티가 상단에 올라오면 어떤 상태?

\- Activity가 중지 상태에서 다시 화면에 표시되기 직전에 호출됩니다. onRestart->onStart->onResume-> ActivityRunning..

##### 6-4. onRestart는 언제 호출이 되나요?

\- Activity가 중지 상태에서 다시 화면에 표시되기 직전에 호출됩니다. onRestart->onStart->onResume-> ActivityRunning..



#### 7. Fragment의 생명주기에 대해 얘기하고 각 항목에 대해 설명

![fragment_lifecycle](/Users/parktaeim/Documents/GitHub/Android-Study/study/week16/안드로이드 개발자로 취업하기 - 면접/images/fragment_lifecycle.png)

**최초 생성 LifeCycle**

1) **onAttatch()** : Fragment가 Activity에 붙을 때 호출

2) **onCreate()** : Activity에서의 oncreate()와 비슷, ui관련 작업X

3) **onCreateView()** : Layout을 inflater하여 View 작업

4) **onActivityCreated()** : Activity에서 Fragment를 모두 생성하고 난 다음 호출, 액티비티의 onCreate()에서 setContentView()한 다음이라고 생각 하면 쉽게 이해 될것 같다. 여기서 부터는 ui변경작업이 가능하다.

5) **onStart()**
Fragment가 화면에 표시될때 호출된다. 사용자의 Action과 상호 작용 할 수 없다.

6) **onResume()**

Fragment가 화면에 완전히 그렸으며, 사용자의 Action과 상호 작용이 가능하다.

**다른 Fragment가 add**

1) **onPause() :**Fragment가 사용자의 Action과 상호 작용을 중지

2) **onStop() :**Fragment가 화면에서 더이상 보여지지 않게 되며, Fragment기능이 중지 되었을때 호출

3) **onDestoryView() : **View 리소스를 해제 할수 있도록 호출, backstack을 사용 했다면 Fragment를 다시 돌아 갈때 onCreateView()가 호출

**Replace or backward로 removed되는 경우**

4) **onDestory() :**Fragment상태를 완전히 종료 할 수 있도록 호출 한다.

5) **onDetach() :**Fragment가 Activity와 연결이 완전히 끊기기 직전에 호출 된다.



#### 8. ANR에 대해 설명

Application Not Responding. 

원인 : 메인스레드(UI 스레드)가 일정 시간 어떤 Task에 잡혀 있으면 발생한다.

input 이벤트에 5초안에 반응하지 않을 때

BroadcastReceiver가 10초내로 실행을 하지 않을 때 (UI가 없는 브로드캐스트 리시버, 서비스도 실행 주체가 메인스레드 이므로 긴 시간을 소모하는 작업인 경우 ANR발생)

##### 8-1. ANR 예방하려면?

1. 시간 소모가 많은 작업은 스레드를 통해 처리
2. 사용자에게 프로그레스바 등을 이용해 작업의 진행과정을 알려 기다리도록 한다.




#### 9. Content Provider와 Content Resolver 차이

![content_provider](/Users/parktaeim/Documents/GitHub/Android-Study/study/week16/안드로이드 개발자로 취업하기 - 면접/images/content_provider.jpeg)

**Content Provider** : 어플리케이션 내에서 사용할 수 있는 데이터를 ‘공유’하기 위한 컴포넌트

Ex) 연락처,이미지 등 (카카오톡)

**Content Resolver** : 앱이 ContentProvider를 접근할 때에는, Content Resolver를 통해 접근하게 됨.  

기본적으로 CRUD 함수들 제공 -> 다른 앱의 데이터베이스를 조작할 수 있음.

Ex) contentResolver.query()



#### 10. XML 기반 레이아웃은 왜 중요?

동작을 제어하는 코드로부터 따로 표시하기가 더 좋음, UI의 구조를 시각화하기 더 쉬움

자바로 레이아웃을 작성했다면, 레이아웃을 변경할 때마다 소스를 재컴파일 해야함.



#### 11. Manifest 설명

애플리케이션에 대한 필수적인 정보를 안드로이드 플랫폼에 알려준다.

모든 안드로이드 앱은 반드시 AndroidManifest.xml 파일을 자신의 루트 디렉토리에 가지고 있어야함.



#### 12. Vector , 비트맵 이미지 차이점

**Vector** : 리사이징이 되어도 전혀 깨지지 않음. 모든 해상도에서 자유자재로 활용할 수 있기 때문에 특정 해상도에 제한되어 있지 않다는 것이 핵심.    Ex) SVG

**비트맵** : 픽셀로 구성되어 있다.  자유자재로 바꿀 수가 없고 움직일 수도 없다.   Ex) PNG, JPEG



#### 13. ConstraintLayout 왜 사용?



</br></br>



## 4. 네트워크 

#### 1. Process Vs. Thread

Process : 실행 중인 하나의 애플리케이션, 사용자가 애플리케이션을 실행하면 운영체제로부터 실행에 필요한 메모리를 할당받아 애플리케이션의 코드를 실행, 하나의 애플리케이션은 다중 프로세스를 만들기도 한다. (크롬 브라우저 두 개 실행 -> 두 개의 크롬 Process 생성)

Thread : 하나의 프로세스 내에서 할당 받은 자원을 공유하며 실행되는 독립적인 작업 단위이다. 즉, 스레드는 각자의 스택 메모리영역을 가지고 있으며 동일한 프로세스 내의 다른 스레드들과 전역 메모리를 공유한다. 따라서 CPU로부터 새로운 자원을 할당받지 않아도 되기 때문에 프로세스보다 실행 속도가 빠르다는 장점을 가지고 있다.

멀티 프로레스들은 운영체제에서 할당받은 자신의 메모리를 가지고 실행하기 때문에 서로 독립적.

따라서 하나의 프로세스에서 오류가 발생해도 다른 프로레스에게 영향을 미치지 않는다.

하지만 Thread는 하나의 프로세스 내부에 생성되기 때문에 하나의 스레드가 예외를 발생시키면 프로세스 자체가 종료될 수 있어 다른 스레드에게 영향을 미치게 된다. 



#### 2. Http vs. Https

공통점: 둘다 인터넷을 이용하는 프로토콜

**Http **: Hypertext transfer protocol, 웹 서버와 사용자의 인터넷 브라우저 사이에 문서를 전송하기 위한 통신규약. 인터넷에서 하이퍼텍스트를 교환하기 위해 사용되는 통신규약.

http에는 사용할 수 있는 메소드가 여러 가지 있다. HEAD, GET, POST, DELETE, OPTION등 

**Https** : http하고 거의 같지만 모든 통신 내용을 암호화. s가 secure socket, 안전한 통신망을 뜻함.

패킷이 암호화 되어 있기 때문에 패킷캡쳐 프로그램으로 캡쳐를 해도 암호화된 내용만 보임.

암호화는 TLS라고 하여 Transport계층에서 이루어짐. L4의 전송계층에서 암호화가 이루어짐.

**근데 왜 http써?**

https암호화를 하려면 웹 서버에 부하가 생김(암호화 과정 때문에 https가 더 느림), 비용이 비쌈. 

http는 비연결형으로 웹 페이지를 보는 중 인터넷 연결이 끊겼다가 다시 연결되어도 페이지를 계속 볼 수 있지만 https는 소켓(데이터를 주고받는 경로) 자체에서 인증을하기 때문에 인터넷 연결이 끊기면 소켓도 끊어져서 다시 https 인증을 해야한다. 그래서 시간이 또 걸린다.

그래서 아무나 봐도 상관없는 페이지는 http로, 남에게 보이면 안되는 금융 정보나 메일 등 중요한 것은 https로 하는 것이다. GMail은 https를 지원한다. 



#### 3. POST vs. GET

GET : URL 마지막단에 ‘?’ 문자를 기준으로 모든 파라미터를 전달, 주소창에 값이 노출되기에 PW와 같은 민감한 정보를 전송하면 안됨, 

POST : 전달하려는 정보가 HTTP body 에 포함되어 전달 -> 사용자에게 직접적으로 파라미터 노출 X

길이에 제한 없음, 서버 혹은 DB의 값이나 상태를 바꿀 때 사용

####   

</br></br>



## 라이브러리

자신의 이력서나 포트폴리오에 기재한 기술들에 대해 알아가야 한다. 

그것이 무슨 라이브러리 인지 보다 **왜 사용하였나**가 더 중요하다.



#### 1. OkHttp와 Retrofit 차이점, 장단점

#### 2. DataBinding 장점 왜사용?

#### 3. Rx 적용했을 때 좋은 점 



</br></br>



## 5. 전공 이외 질문

- 자기소개
- 지원동기
- 코딩하면서 행복했던 일, 힘들었던 일
- 최근 가장 관심있는 기술
- 다니고 있는 컨퍼런스나 대외활동 자주 다니는지
- 마이스터고에 왜 진학?
- 혼자 어떤방식으로 공부?
- 신기술은 어디서 알게됨?
- 좋은 회사란?
- 좋은 코드란?
- 개발자로서 나의 목표



</br></br>



## 6. 마지막 준비해 갈것

#### 1. 회사 주력 서비스 미리 설치해서 본 후 오류, 아쉬운 점, 좋은 점 알아가기

앱 쓰면서 고쳤으면 하는 것 미리 생각해보기.



#### 2. 마지막 질문 생각해가기

면접이 끝나고 마지막에 정말 꼭 마지막에 "궁금한 것 있으세요?" 라고 물어본다. 그 때 여쭤볼 질문들을 미리 생각해가자. 막상 가면 머릿속이 하얘져서 미리 준비해놓은 것도 기억이 안난다… 

##### 2-1. 내가 준비해간 질문

- 배포 주기는 어떻게 되는가?
- 회사 전체 인원과 그 중 개발자 비율은?
- 개발자 중 내 분야(안드로이드) 개발자는 몇명?
- 주니어 시니어 비율은?
- 사내에 정착되어 있는 개발문화가 있나요? (코드리뷰 등..)
- 사수가 있나요?

등등등…



</br></br>


